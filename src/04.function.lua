---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by DongjianPeng.
--- DateTime: 2022/6/26/0026 18:19
--- 函数
---
print("------------------分隔线----------------")

print("print 函数")  -- print 函数

local m = math.max(1, 3, 5, 2)
print(m)  -- 5
local mm = math.max

print(mm(4, 6, 3)) -- 6

-- 自定义函数
function my_function(user, pass)
    local temp = "error"
    print(user, pass)
    temp = user
    print(temp)  -- aa
end

my_function("aa", "opij") -- aa	opij

print(temp)  -- nil

local function max(a, b)
    --定义函数 max，用来求两个数的最大值，并返回
    local temp = nil       --使用局部变量 temp，保存最大值
    if (a > b) then
        temp = a
    else
        temp = b
    end
    return temp            --返回最大值
end

local m = max(-12, 20)    --调用函数 max，找去 -12 和 20 中的最大值
print(m)                  --> output 20

local function func()
    --形参为空
    print("no parameter")
end

func()                  --函数调用，圆扩号不能省

local foo = {}
function foo.bar(a, b, c)
    print(a, b, c)
end

foo.bar(1, 3, 4) -- 1	3	4

---- 和上面的等价
foo.bar = function(a, b, c)
    print(a, b, c)
end

foo.bar(1, 3, 4) -- 1	3	4

-- 参数 值传递
local function swap(a, b)
    local temp = a
    a = b
    b = temp
    print(a, b)
end

local x, y = "x", 21
print(x, y)
swap(x, y)
print(x, y)

local function fun1(a, b)
    print(a, b)
end

local function fun2(a, b, c, d)
    print(a, b, c, d)
end
---- 从左到右忽略参数
local x, y, z = 1, 2, 3
fun1(x, y, z) -- 1	2
fun2(x, y, z) -- 1	2	3	nil
---- 可变参数，切记jit目前还不能编译可变参数，只能解释执行，所以性能有影响
local function fun3(...)
    -- 形参用...
    local temp = { ... } -- 访问的时候也用...
    local ans = table.concat(temp, ",")
    print(ans)
end
fun3(1, 2, 4, "xx")  -- 1,2,4,xx
---- 具名参数
local function change(arg)
    arg.w = arg.w * 2
    arg.h = arg.h * 2
    return arg
end
local rectangle = { w = 20, h = 50 }
print("before:", rectangle.w, rectangle.h)
change(rectangle) -- 引用传递
---- 也可以  rectangle = change(rectangle)
print("after:", rectangle.w, rectangle.h)
---- 引用传递  table作为参数，传递进来的是实际参数的引用

-- 函数返回值，lua和go一样可以有多个返回值，跟函数参数一样，多余的值会被忽略，不够的值会用nil
local s1, s2 = string.find("hello world", "llo")
print(s1, s2) -- 3	5

local function swap(a, b)
    return b, a
end
local a, b = 4, 5
print(a, b) -- 4	5
a, b = swap(a, b)
print(a, b) -- 5	4

local function init()
    -- init 函数 返回两个值 1 和 "lua"
    return 1, "lua"
end

local x, y, z = init(), 2   -- init 函数的位置不在最后，此时只返回 1
print(x, y, z)              -->output  1  2  nil

local a, b, c = 2, init()   -- init 函数的位置在最后，此时返回 1 和 "lua"
print(a, b, c)              -->output  2  1  lua

local function init()
    return 1, "lua"
end
---- 注意，这种没有用()的，只能被解释执行
print(init(), 2)   -->output  1  2
print(2, init())   -->output  2  1  lua
---- 用括号来限定只返回一个返回值
local function init()
    return 1, "lua"
end

print((init()), 2)   -->output  1  2
print(2, (init()))   -->output  2  1

-- 全动态函数调用
---- unpack内建函数不能jit编译，所以只能解释执行
local function run(x, y)
    print('run', x, y)
end
local function attack(targetId)
    print('targetId', targetId)
end
local function do_action(method, ...)
    local args = { ... } or {}
    method(unpack(args, 1, table.maxn(args)))
end

do_action(run, 1, 2)  -- run	1	2
do_action(attack, 1111)  -- targetId	1111


local _M = {}

local function get_name()
    return "Lucy"
end

function _M.greeting()
    print("hello " .. get_name())
end

return _M