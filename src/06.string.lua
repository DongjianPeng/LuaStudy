---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by DongjianPeng.
--- DateTime: 2022/6/26/0026 18:20
--- 字符串
---
print("------------------分隔线----------------")
-- string.byte(s [, i [, j ]])  返回对应的ASCII码
---- i 的默认值为 1，即第一个字节,j 的默认值为 i
print(string.byte("abc", 1, 3)) -- 97	98	99
print(string.byte("abc", 3)) -- 99
print(string.byte("abc")) -- 97
print(string.byte("abc", 2)) -- 98

print("------------------分隔线----------------")
-- string.char (...)  接收 0 个或更多的整数（整数范围：0~255），返回这些整数所对应的 ASCII 码字符组成的字符串
---- 比.. 和 table.concat高效
print(string.char(96, 97, 98)) -- `ab
print(string.char())        -- 参数为空，默认是一个0，
print(string.byte(string.char() .. "")) -- 啥也不是
print(string.char(65, 66))  --  AB

print("------------------分隔线----------------")
-- 字符串大小写转换
print(string.upper("Hello Lua"))  -->output  HELLO LUA
print(string.lower("Hello Lua"))  -->output   hello lua

print("------------------分隔线----------------")
-- 字符串长度
print(string.len("hello lua")) -->output  9
local str = "is string!"
print(#str) -- 10  推荐用这个

print("------------------分隔线----------------")
-- string.find(s, p [, init [, plain]])
local find = string.find
print(find("abc cba", "ab"))  -- 1	2  返回ab在 abc cba中的开始位置和结束位置，所以会返回1 2
print(find("abc cba", "ab", 2))     -- 从索引为2的位置开始匹配字符串：ab
print(find("abc cba", "ba", -1))    -- 从索引为7的位置开始匹配字符串：ba
print(find("abc cba", "ba", -3))    -- 从索引为5的位置开始匹配字符串：ba
print(find("abc cba", "(%a+)", 1))  -- 从索引为1处匹配最长连续且只含字母的字符串
print(find("abc cba", "(%a+)", 1, true)) --从索引为1的位置开始匹配字符串：(%a+)

print("------------------分隔线1----------------")
print(string.format("%.4f", 3.1415926))     -- 保留4位小数
print(string.format("%d %x %o", 31, 31, 31))  -- 十进制数31转换成不同进制
d = 29;
m = 7;
y = 2015                     -- 一行包含几个语句，用；分开
print(string.format("%s %02d/%02d/%d", "today is:", d, m, y))

print("------------------分隔线----------------")
---- string.match 目前并不能被 JIT 编译，应 尽量 使用 ngx_lua 模块提供的 ngx.re.match 等接口
print(string.match("hello lua", "lua"))
print(string.match("lua lua", "lua", 2))  --匹配后面那个lua
print(string.match("lua lua", "hello"))
print(string.match("today is 27/7/2015", "%d+/%d+/%d+"))

print("------------------分隔线-gmatch---------------")
---- 此函数目前并不能被 LuaJIT 所 JIT 编译，而只能被解释执行。应 尽量 使用 ngx_lua 模块提供的 ngx.re.gmatch 等接口
s = "hello world from Lua"
for w in string.gmatch(s, "%a+") do
    --匹配最长连续且只含字母的字符串
    print(w)
end

t = {}
s = "from=world, to=Lua"
for k, v in string.gmatch(s, "(%a+)=(%a+)") do
    --匹配两个最长连续且只含字母的
    t[k] = v                                    --字符串，它们之间用等号连接
end
for k, v in pairs(t) do
    print(k, v)
end

print("------------------分隔线-rep---------------")
print(string.rep("abc", 3)) --拷贝3次"abc"

print("------------------分隔线sub----------------")
print(string.sub("Hello Lua", 4, 7)) --lo L
print(string.sub("Hello Lua", 2)) -- ello Lua
print(string.sub("Hello Lua", 2, 1))    --当索引 i 在字符串 s 的位置在索引 j 的后面时，将返回一个空字符串
print(string.sub("Hello Lua", -3, -1)) -- Lua

print("------------------分隔线-gsub---------------")
---- 此函数不能为 LuaJIT 所 JIT 编译，而只能被解释执行。一般我们推荐使用 ngx_lua 模块提供的 ngx.re.gsub 函数
print(string.gsub("Lua Lua Lua", "Lua", "hello"))  -- hello hello hello	3
print(string.gsub("Lua Lua Lua", "Lua", "hello", 2)) --指明第四个参数 替换2次  -- hello hello Lua	2

print("------------------分隔线----------------")
print(string.reverse("Hello Lua"))  --> output: auL olleH
